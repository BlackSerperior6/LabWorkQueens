#include <iostream>

using namespace std;

int IterationsCounter = 0; //Общий счетчик итераций рекурсии

void setQueen(int **board, int row, int column, int boardSize) //Фукнкция для постановки королевы на клетку. Принимает в себя: строку и ряд клетки, а также размер доски
{
    for (int x = 0; x < boardSize; x++) //Запускаем цикл
    {
        //Прибавляем единицу к клеткам, которые бьет королева (тем самым получая, сколько королев бьют эту клетку)
        board[x][column]++;
        board[row][x]++;

        //Получаем клетку по диагонали
        int diagonal = column - row + x;

        //Если диагональная клетка находится в пределах доски, то пометить её как ту, которую может удраить королева
        if (diagonal >= 0 && diagonal < boardSize)
            board[x][diagonal]++;

        //Аналогично логике выше
        diagonal = column + row - x;

        if (diagonal >= 0 && diagonal < boardSize)
            board[x][diagonal]++;
    }

    board[row][column] = -1; //Саму клетку королевы пометим, как равную -1
}

void removeQueen(int** board, int row, int column, int boardSize) //Функция для снятия королевы с клетки. Принимает в себя: строку и ряд клектки, а также размер доски
{
    //Логика работы функции абсолютно аналогична логике работы функции выше, за исключением того, что здесь мы убавляем значения, а не прибавляем
    for (int x = 0; x < boardSize; x++)
    {
        board[x][column]--;
        board[row][x]--;

        int diagonal = column - row + x;

        if (diagonal >= 0 && diagonal < boardSize)
            board[x][diagonal]--;

        diagonal = column + row - x;

        if (diagonal >= 0 && diagonal < boardSize)
            board[x][diagonal]--;
    }

    board[row][column] = 0; //Саму клетку королевы пометим, как 0 (полностью свободная)
}

void PrintOutBoard(int** Board, int n) //Функция для печати доски в консоль. Использует вложенные циклы
{
    cout << "Доска на данный момент (! - королевы, x - места, которые они бьют, o - свободнные клетки): " << endl;

    for (int row = 0; row < n; row++)
    {
        for (int square = 0; square < n; square++)
        {
            switch (Board[row][square])
            {
            case -1: //-1 - обозначение для королевы
                cout << "!" << " ";
                break;
            case 0: //0 - обозначение для полностью свободной клетки
                cout << "o" << " ";
                break;
            default: //Значения от 1 до n - клетки, которые может ударить королева
                cout << "x" << " ";
                break;
            }
        }

        cout << endl; //Переход на следующую строку после печати ряда доски
    }
}

bool safeCheck(int *Row, int size) //Функция для проверки массива на наличие элементов, не равных -1 (где в данном случае -1 обозначает клетку, в которую нельзя ставить королеву)
{
    bool flag = false; //Переменная флага
    int counter = 0; //Переменная счетчика

    while (!flag && counter < size) //Пока не нашли не -1 элемент и не дошли до конца массива
    {
        flag = Row[counter] != -1; //Присваимаем флагу значение того, не равен ли элемент по счетчику -1
        counter++; //Прибвляем счетчик
    }

    return flag; //Возвращаем флаг
}

bool PutQueens(int **Board, int row, int n, int rootId) //Рекурсивная функция для решения задачи. Принимает в себя текущий ряд, размеры доски/кол-во королев, а также id родительской итерации (для первой итерации равной 0)
{
    int id = ++IterationsCounter; //Присваем итерации рекурсии id номер

    cout << "Создание новой итерации с id = " << id << ", ряд: " << row + 1 << ", id родительской итерации: " << rootId << endl << endl;

	bool result = false; //Флаг того, смогли ли мы успешно поставить королев на всей доске 
    bool flag = false; //Флажок, который обозначает, провалилась ли попытка поставить королев из - за того, что небыло свободных мест на последующих рядах (дургой способ провалиться - в принципе не было свободных мест на ряде с самого начала)

    int *availablePlaces = new int[n]; //Массив индексов доступных клеток, на которые можно поставить королеву

    for (int i = 0; i < n; i++)
        availablePlaces[i] = Board[row][i] == 0 ? i : -1; //Заполняем массив выше. Если клетка пустая, то записываем её индекс, иначе записываем -1.

    while (!result && safeCheck(&availablePlaces[0], n)) //Цикл, который будет работать до тех пор, пока не поставлены королевы на всей доске и пока есть свободные места в ряду
    {
        int place; //Переменная, хранящая в себе индекс выьранной клетки

        do
        {
            place = availablePlaces[rand() % n]; //Через цикл получаем случайную свободную клетку
        } 
        while (place == -1);

        cout << "Случайным образом выбрана позиция для постановки новой королевы: " << row + 1 << ":" << place + 1 << endl << endl;

        setQueen(Board, row, place, n); //Ставим королеву на выбранную клетку

        PrintOutBoard(Board, n); //Печатаем доску

        cout << endl << endl;

        if (row == (n - 1)) //Если мы на последнем ряду, что присваиваем результату значение true и выходим из рекурсии
        {
            cout << endl << "Все королевы были успешно расставлены!" << endl << endl;
            result = true;
        }
        else
        {
            cout << "Переход на следующий ряд, создание новой итерации!" << endl << "---------------------------" << endl;
            result = PutQueens(Board, row + 1, n, id); //Иначе переходим на следующий ряд
        }

        if (!result) //Если не получилось расставить всех королев на доске при выбранной клетке, то
        {
            flag = true;
            removeQueen(Board, row, place, n); //Убираем королеву с этой клетки
            cout << "Не удалось успешно поставить королев в последующие ряды при условии, что в ряде " << row + 1 << " королева стоит на " << place + 1 << " месте" << ". Пытаемся выбрать новое место" << endl << endl;
            PrintOutBoard(Board, n); //Печатаем доску
            cout << "---------------------------" << endl;
            availablePlaces[place] = -1; //Помечаем это место как то, в которое нельзя ставить королеву
        }
    }

    if (!result && !flag)
        cout << "Не нашли место для королевы в ряде " << row + 1 << ". Возвращаемся на предыдущий ряд " << "(" << row << ")" << " (id, в который вернемся:  " << rootId << ")" << endl << "---------------------------" << endl;

    delete[] availablePlaces; //Очищаем память от массива мест в ряду
    return result; //Возвращаем результат
}

int main()
{
    setlocale(LC_ALL, "RUS"); //Подключаем русский язык
    srand(time(0)); //Инициализируем генератор случайных чисел

    int n;

    cout << "Введите число королев и размер доски одним числом" << endl;

    cin >> n; //Получаем размер доски и кол-во королев от пользователей
     
    if (n < 4) //Проверка на валидность. Для единицы есть одно тривиальное решение, нету смысла его выводить. Для 2 и 3 решений нет, поэтому ввод пользователя должен быть больше или равен 4
    {
        cout << "Размер доски и кол-во королев должны быть >= 4" << endl;
        return 0;
    }

    int** Board = new int*[n]; //Инициализация динамической матрицы

    cout << endl << "---------------------------" << endl;

    //Заполняем матрицу нулями (пустыми клетками)
    for (int row = 0; row < n; row++)
    {
        Board[row] = new int[n];

        for (int square = 0; square < n; square++)
            Board[row][square] = 0;
    }

    PutQueens(&Board[0], 0, n, 0); //Запускаем рекурсивную функцию

    cout << endl << "Всего потребовалось итераций: " << IterationsCounter << endl;

    //Чистим память от доски
    for (int i = 0; i < n; i++)
        delete [] Board[i];

    delete [] Board;
}
